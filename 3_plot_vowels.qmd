---
title: "Part 3: Plotting the Vowels"
number-offset: [0, 3, 0]
---

<br>

Now to actually make the vowel plots! This document goes into detail about how I decided to make them the way I did and how to implement them in ggplot, but if you just want to see the final results, jump down to [here](#results).

### Setup

```{r}
#| label: imports
#| message: false

library(tidyverse)    # <1>
library(magrittr)     # <2>
library(ggtext)       # <3>
library(ggforce)      # <4>
library(ggrepel)      # <5>
library(rcartocolor)  # <6>
library(png)          # <7>
library(patchwork)    # <8>

options(dplyr.summarise.inform = FALSE)  # <9>
```

1.  Data wrangling (`tidyr`, `dplyr`, `purrr`, `stringr`), `ggplot2` for plotting.
2.  Pipe operator.
3.  Markdown/HTML formatting for text in plots.
4.  Ellipsis plots.
5.  Offset text labels from points.
6.  Color themes.
7.  Open PNG images.
8.  Add images on top of plots.
9.  Don't print a message every time `summarise()` is called on a grouped dataframe.

(Note: this could be done in Python, but I strongly prefer the [ggplot package](https://ggplot2.tidyverse.org/) for plotting.)

#### Data {.unnumbered}

Load the vowel formant data from [Part 2](2_annotate_audio.qmd):

```{r}
#| label: load-formants

formants <- read.csv("data/formants.csv", stringsAsFactors = TRUE) %>%  # <1>
  select(-Vowel_Time, -Count) %>%  # <1>
  mutate(  # <2>
    Speaker = ifelse(Speaker == "G", "Gretchen", "Lauren"),  # <2>
    List = ifelse(
      List == "episode", "Lingthusiasm Episodes", "Wells Lexical Set"
    )  # <2>
  ) %>%  # <2>
  mutate(across(where(is.character), as.factor))  # <2>

str(formants)
```

1.  Read formants data from `2_annotate_audio.qmd`, and keep columns for `List`, `Vowel`, `Word`, `Speaker`, `F1`, and `F2`.
2.  Recode the values for `Speaker` and `List` from abbreviations to full strings for plot labels, then make them both factors.

#### IPA Symbols {.unnumbered}

However, the IPA symbols aren't encoded correctly. They'll render in RStudio, but not when Quarto renders the document to HTML, or always when ggplot renders the plots. This isn't what we want:

> `r formants$Vowel %>% as.factor() %>% levels()`

So, the next step is to enter the unicode values manually (copied from this [Wikipedia page](https://en.wikipedia.org/wiki/Phonetic_symbols_in_Unicode#Vowels)):

```{r}
#| label: ipa-vowels

vowels <- c(
  "i_lower"   = "\u0069",  # i (close front unrounded)
  "i_upper"   = "\u026A",  # ɪ (near-close front unrounded)
  "epsilon"   = "\u025B",  # ɛ (open-mid front unrounded)
  "ash"       = "\u00E6",  # æ (near-open front unrounded)
  "schwa"     = "\u0259",  # ə (mid central)
  "horseshoe" = "\u028A",  # ʊ (near-close near-back rounded)
  "u"         = "\u0075",  # u (close back rounded)
  "o"         = "\u006F",  # o (close-mid back rounded)
  "hat"       = "\u028C",  # ʌ (open-mid back unrounded)
  "open_o"    = "\u0254",  # ɔ (open-mid back rounded)
  "alpha"     = "\u0251"   # ɑ (open back unrounded)
)
```

These are ordered from front to back, then close to open (@fig-ipa).

Then match the unicode for the IPA symbol to the words:

```{r}
#| label: fix-vowel-symbols

formants %<>% mutate(
  Vowel = case_when(  # <1>
    Word %in% c("ball", "father", "honorific", "lot", "palm", "start") ~ vowels["alpha"],
    Word %in% c("bang", "bath", "hand", "laugh", "trap") ~ vowels["ash"],
    Word %in% c("bought", "cloth", "core", "north", "thought", "wrong") ~ vowels["open_o"],
    Word %in% c("among", "famous", "support") ~ vowels["schwa"],
    Word %in% c("bet", "dress", "guest", "says", "square") ~ vowels["epsilon"],
    Word %in% c("beat", "believe", "fleece", "people") ~ vowels["i_lower"],
    Word %in% c("bit", "finish", "kit", "near", "pin") ~ vowels["i_upper"],
    Word %in% c("force", "goat") ~ vowels["o"],
    Word %in% c("blue", "goose", "through", "who") ~ vowels["u"],
    Word %in% c("could", "cure", "put", "foot") ~ vowels["horseshoe"],
    Word %in% c("another", "but", "fun", "strut") ~ vowels["hat"],
  ) %>% factor(levels = vowels, ordered = TRUE)  # <2>
)

str(formants)
```

1.  If the value in the `Word` column is `ball`, `father`, `honorific`, `lot`, or `palm`, then assign the `alpha` value from the `vowels` list.
2.  Convert character to factor, then specify the order of the factors (same as in `vowels` list above) to make sure it stays consistent.

Now the IPA vowels consistently render correctly: 

> `r levels(formants$Vowel)`

#### Lingthusiasm Theme {.unnumbered}

The Lingthusiasm font is `Josefin Sans`, which is available from [Google Fonts](https://fonts.google.com/specimen/Josefin+Sans/glyphs).

I downloaded and installed it to my computer. There are a number of different ways to add new fonts without having to install them separately outside of RStudio, such as `font_add_google()` from the [showtext package](https://cran.rstudio.com/web/packages/showtext/vignettes/introduction.html). However, that method was causing errors rendering the IPA symbols.

`systemfonts()` shows the list of fonts installed on my computer that R recognizes, and it finds Josefin Sans:

```{r}
#| label: load-fonts-1

systemfonts::system_fonts() %>%  # <1>
  filter(str_detect(family, "Josefin Sans")) %>%  # <2>
  select(path, name, family) %>%  # <3>
  pivot_longer(cols = everything())  # <3>
```

1.  Get dataframe of fonts available.
2.  Filter to include `Josefin Sans`.
3.  Select columns to print; flip to list vertically.

However, the fonts loaded by default just include Times New Roman, Arial, and Courier New:

```{r}
#| label: load-fonts-2

windowsFonts()
```

This tells R to load Josefin Sans into the set of available fonts, so text will render in Josefin Sans if `family = sans_alt`, but stick with the default sans font otherwise (and not break the IPA symbols).

```{r}
#| label: load-fonts-3

windowsFonts(sans_alt = "Josefin Sans")
windowsFonts()
```

The hex codes for the green and navy are:

```{r}
#| label: lingthusiasm-colors

lingthusiasm_green = "#26b14c"
lingthusiasm_navy = "#051458"
```

And the logo:

```{r}
#| label: lingthusiasm-logo

lingthusiasm_logo <- readPNG("resources/lingthusiasm_logo_circle.png",  native = TRUE)  # <1>
lingthusiasm_tagline <- readPNG("resources/lingthusiasm_logo_tagline.png",  native = TRUE)  # <1>
```

1.  Read logo images. `native = TRUE` specifies reading it as a raster object instead of an array, which is the format `patchwork::inset_element()` needs.

Putting it together:

```{r}
#| label: fig-lingthusiasm-theme
#| fig-cap: Lingthusiasm colors, font, and logo.
#| fig-asp: 1

tibble(
  "Color" = c("green", "navy"),  # <1>
  "Hex" = c(lingthusiasm_green, lingthusiasm_navy),  # <2>
  "Extra_Col" = c(1, 1)  # <3>
) %>%
  ggplot(aes(x = Color, y = Extra_Col, fill = Hex, label = Hex)) +  # <4>
  geom_tile() +  # <5>
  geom_text(size = 10, color = "white") +  # <6>
  scale_fill_identity() +  # <7>
  theme_classic() +
  labs(title = "Lingthusiasm Theme") +  # <8>
  theme(
    plot.title = element_text(  # <8>
      family = "sans_alt", size = 28,  # <8>
      margin = margin(t = 1, b = 1, unit = "lines"), hjust = 0.55,  # <8>
      color = lingthusiasm_navy  # <8>
    ),  
    axis.text = element_blank(), axis.title = element_blank(),  # <9>
    axis.line = element_blank(), axis.ticks = element_blank()   # <9>
  ) +
  inset_element(  # <10>
    p = lingthusiasm_logo,  # <10>
    left = unit(0.05, "snpc"), right = unit(0.25, "snpc"),  # <11>
    top = unit(1.2, "snpc"), bottom = unit(1, "snpc")  # <11>
  )
```

1.  `Color` is names of the two lingthusiasm theme colors.
2.  `Hex` is the two hex codes.
3.  `Extra_Col` is a dummy value because ggplot needs a Y axis.
4.  The X axis is `Color`, and the Y axis is `Extra_Col`, which just creates two boxes next to each other. Fill and label are specified by `Hex`.
5.  Draw a square for each color.
6.  Label the squares with the hex code strings (keeping the default font).
7.  Fill the squares with the hex code color values.
8.  Set the plot title text to be navy, Josefin Sans, size 28, centered with some space above and below.
9.  Remove the axis lines, labels, titles, and ticks.
10. Use the `patchwork` package to add the logo image on top of the plot. This step needs to be last.
11. Specify the positions for each corner of the logo, using `spnc` units so it stays square even if the overall plot is rectangular.

### Plot Vowel Means

Now let's take a look at the data! F1 gets plotted on the Y axis, and F2 gets plotted on the X axis.

```{r}
#| label: fig-vowel-means-1
#| fig-cap: "Vowel means (default axes)."

means_1 <- formants %>%  # <1>
  group_by(Speaker, List, Vowel) %>%  # <1>
  summarise(F1 = mean(F1), F2 = mean(F2)) %>% # <1>
  ggplot(aes(x = F2, y = F1, label = Vowel)) +  # <2>
  geom_textbox(  # <3>
    fill = lingthusiasm_green, box.colour = NA,  # <4>
    color = "white", size = 4.5, halign = 0.5, valign = 0.5, # <5>
    width = unit(0.10, "snpc"), height = unit(0.10, "snpc"),  # <6>
    box.padding = unit(c(0, 0, 0, 0), "snpc"), box.r = unit(0.01, "snpc")  # <7>
  ) +  
  facet_grid(Speaker ~ List) +  # <8>
  theme_classic() +  # <9>
  theme(
    axis.line = element_line(color = lingthusiasm_navy),  # <10>
    axis.ticks = element_line(color = lingthusiasm_navy),  # <10>
    panel.border = element_rect(color = lingthusiasm_navy, fill = NA),  # <10>
    strip.background = element_rect(color = lingthusiasm_navy),  # <10>
    text = element_text(size = 12, family = "sans_alt", color = lingthusiasm_navy),  # <11>
    axis.text = element_text(color = lingthusiasm_navy),  # <11>
    strip.text = element_text(color = lingthusiasm_navy, size = 12)  # <11>
  ) +
  labs(title = "Vowel Means")  # <12>

means_1
```

1.  Take the full data set, group it by `Speaker` then `List` then `Vowel`, and then calculate the means of `F1` and `F2` for each `Speaker` x `List` x `Vowel`.
2.  All layers of the plot have `F2` on the X axis, `F1` on the Y axis, and are labelled by `Vowel`.
3.  Write the vowel symbols (because `Label = Vowel`) at the location of their means.
4.  Make the text box background lingthusiasm green with no outline.
5.  Make the text white, size 4.5 (note that this is on a different scale than the rest of the text sizes specified in later `theme()`), vertically and horizontally centered.
6.  Set the size of the text boxes, using `snpc` (squared normalized parent coordinates) to be relative to the size of the plot but always square.
7.  No margins inside the text boxes and a slight curve on the corners.
8.  Split the plot to have Gretchen's data in the top panels and Lauren's data in the bottom panels, and the data from the Lingthusiasm episodes in the left panels and the data from the Wells lexical set recordings in the right panels.
9.  Change the default theme to have a white background with no grid lines.
10. Change all the lines (axis lines, axis ticks, outline around panels, outline around panel labels) to be the lingthusiasm navy.
11. Make all the text navy Josefin Sans. Set the base size as 12, but make the text of the speaker panel labels bigger.
12.  Set the title, and leave the other axis/legend labels as their default values of "F1", "F2", and "Vowel."

(Sidenote: saving the theme specifications so we don't have to keep retyping theme.)

```{r}
#| label: lingthusiasm-plot-theme

lingthusiasm_theme <- theme(
  axis.line = element_line(color = lingthusiasm_navy),
  axis.ticks = element_line(color = lingthusiasm_navy),
  panel.border = element_rect(color = lingthusiasm_navy, fill = NA),
  strip.background = element_rect(color = lingthusiasm_navy),
  text = element_text(size = 12, family = "sans_alt", color = lingthusiasm_navy),
  axis.text = element_text(color = lingthusiasm_navy),
  strip.text = element_text(color = lingthusiasm_navy, size = 12)
) 
```

However, vowel plots typically have their axes reversed, so that the highest value of (F1, F2) is at the bottom left corner instead of the top right corner. This isn't standard data visualization procedure, but it has a cool and useful result.

```{r}
#| label: fig-vowel-means-2
#| fig-cap: "Vowel means (reversed axes)."

means_2 <- formants %>%  # <1>
  group_by(List, Speaker, Vowel) %>%
  summarise(F1 = mean(F1), F2 = mean(F2)) %>%
  ggplot(aes(x = F2, y = F1, label = Vowel)) +
  geom_textbox(
    fill = lingthusiasm_green, box.colour = NA,
    color = "white", size = 4.5, halign = 0.5, valign = 0.5,
    width = unit(0.10, "snpc"), height = unit(0.10, "snpc"),
    box.padding = unit(c(0, 0, 0, 0), "snpc"), box.r = unit(0.01, "snpc")
  ) +  
  facet_grid(Speaker ~ List) +
  scale_x_reverse(breaks = c(1000, 1500, 2000, 2500)) +  # <2>
  scale_y_reverse(limits = c(1050, 225), n.breaks = 4) +  # <3>
  theme_classic() +
  lingthusiasm_theme +  # <4>
  labs(title = "Vowel Means")

means_2
```

1.  Just annotating the lines that changed from the previous chunk.
2.  Add this to flip the X axis. Specify `breaks` because the default values aren't even.
3.  Add this to flip the Y axis. The limits (see how they're reversed) are specified because the defaults were a bit too narrow, and like this the axis ticks/labels are spaced more evenly.
4.  Add this to specify the colors and font sizes etc.

Now the layout resembles the IPA vowel chart! Front vowels are on the left, and back vowels are on the right; close vowels are on the top, and open vowels are on the bottom.

[![IPA Vowel Chart.](resources/ipa_chart.png){#fig-ipa}](https://commons.wikimedia.org/wiki/File:Ipa-chart-vowels.png)

### Plot Individual Data Points

Just plotting the means for each vowel loses a lot of information, so let's take a look at the underlying data.

Now, we'll distinguish between vowels by color. First, make a legend that will be easier to read than the default by creating a string that prints each vowel in its corresponding color (using the [ggtext package](https://wilkelab.org/ggtext/) to render the HTML formatting).

```{r}
#| label: vowel-key

vowel_key <- tibble("Vowel" = vowels, "Color" = carto_pal(12, "Bold")[1:11]) %>%  # <1>
  mutate(Styled = str_c("<b style='color:", Color, "'>", Vowel, "</b>")) %>%  # <2>
  pull(Styled) %>%  # <3>
  str_flatten(collapse = ", ")  # <3>

vowel_key %>% str_wrap(32) %>% str_view()  # <4>
```

1.  `Vowel` column is the list of vowels (unicode codes). `Color` column is the hex codes from the `Bold` palette in `rcartocolor`, the color set we've been using so far. (Using the first 11 values from the full palette, so the last color isn't gray.)
2.  Encase with HTML code, so that hex code becomes a `color` argument for the vowel character.
3.  Merge into 1 string, with each value separated by a comma + space. 4.. Print, wrapping lines on each item.

Which will render like this:

> `r vowel_key`

(Note that ggplot will throw a warning like `Warning in text_info(label, fontkey, fontfamily, font, fontsize, cache): unable to translate '<U+0251>png215' to native encoding`, but it renders correctly, so the warnings are turned off in those code chunks.)

```{r}
#| label: fig-by-point
#| fig-cap: "Individual data points."

points <- formants %>%  # <1>
  ggplot(aes(x = F2, y = F1, color = Vowel, label = Vowel)) +
  geom_point(size = 1.5) +  # <2>
  facet_grid(Speaker ~ List) +
  scale_color_manual(values = carto_pal(12, "Bold")) +  # <3>
  scale_x_reverse(breaks = c(750, 1250, 1750, 2250, 2750)) +  # <4>
  scale_y_reverse(breaks = c(250, 500, 750, 1000)) +  # <4>
  theme_classic() +
  lingthusiasm_theme +
  theme(plot.subtitle = element_markdown(family = "sans")) +  # <5>
  labs(title = "Individual Data Points", subtitle = vowel_key) +  # <6>
  guides(color = guide_none())  # <7>

points
```

1.  Passing the full data set, not the means by `Speaker` + `Vowel` + `List`, to ggplot.
2.  Instead of `geom_text()`, `geom_point()` is a layer drawing scatterplot (`size` making the points slightly bigger than default).
3.  Use the `Bold` color palette from the `rcartocolor` package to color-code the vowels. (There are 11 vowels, but I specify 12 colors here so the grey gets skipped.)
4.  Limits need to be slightly bigger than plots with vowel means, and then breaks adjusted so that that Y axis labels don't overlap with each other between the two panels.
5.  `element_markdown()` from `ggtext` will render the HTML string. Use default sans serif font because Josefin Sans doesn't have all of the IPA symbols.
6.  Add the color-coded list of vowels as a subtitle.
7.  Turn the default legend off.

### Plot Word Means

The data for each vowel consists of 3 different words. How different are they?  First, let's look at the Wells Lexical Set.

These next plots use the [ggrepel package](https://ggrepel.slowkow.com/) to make the word labels not overlap with each other or with the scatterplot points.

```{r}
#| label: fig-by-word-ls
#| fig-cap: "Mean for each word in the Wells Lexical Set word list."
#| fig-asp: 0.6

words_ls <- formants %>%  # <1>
  filter(List == "Wells Lexical Set") %>%  # <1>
  group_by(Speaker, Vowel, Word) %>%  # <2>
  summarise(F1 = mean(F1), F2 = mean(F2)) %>%  # <2>
  ggplot(aes(x = F2, y = F1, color = Vowel, label = Word)) +  # <3>
  geom_point(size = 1.25) +  # <4>
  geom_label_repel(  # <5>
    min.segment.length = 0,  # <6>
    size = 4,  # <7>
    force = 75,  # <8>
    family = "sans_alt",  # <9>
    seed = 2024  # <10>
  ) +
  facet_wrap(~Speaker) +  # <11>
  scale_color_manual(values = carto_pal(12, "Bold")) +
  scale_x_reverse(breaks = c(750, 1250, 1750, 2250, 2750)) +  # <12>
  scale_y_reverse(breaks = c(250, 500, 750, 1000)) +  # <12>
  theme_classic() +
  lingthusiasm_theme +
  theme(plot.subtitle = element_markdown(size = 15, family = "sans")) +
  labs(title = "Means By Word: Wells Lexical Set", subtitle = vowel_key) +  # <13>
  guides(color = guide_none())  # <13>

words_ls
```

1. Only include `Wells Lexical Set` word list.
2.  The data for this plot is the means by `Speaker`, `Vowel`, AND `Word`.
3.  All layers of this plot have `F2` on the X axis, `F1` on the Y axis, are color-coded by `Vowel`, and are labelled by `Vowel`.
4.  Draw a point at each `Speaker`\*`Vowel`\*`Word` mean (slightly bigger than default).
5.  Draw text box labels offset from each point. `geom_label_repel()` makes sure none of the boxes overlap with the points or with each other.
6.  Always draw a line from the text box to the scatterplot point,
7.  Text size. Note this is on a different scale than the text for the title/axis labels.
8.  Increase the amount of space required between the text boxes.
9.  Make font Josefin sans.
10. Set a seed so the results are consistent.
11. Put Gretchen on the left and Lauren on the right.
12. Specify limits and locations of labels/breaks, since the defaults aren't even.
13. Include color-coded vowel string as a subtitle, instead of the default legend for color.

Now let's look at the Lingthusiasm episode words:

```{r}
#| label: fig-by-word-ep-1
#| fig-cap: "Mean for each word in the Lingthusiasm Episode word list."
#| fig-asp: 1.25

words_ep_1 <- formants %>%  # <1>
  filter(List == "Lingthusiasm Episodes") %>%  # <1>
  group_by(Speaker, Vowel, Word) %>%
  summarise(F1 = mean(F1), F2 = mean(F2)) %>%
  ggplot(aes(x = F2, y = F1, color = Vowel, label = Word)) +
  geom_point(size = 1.25) +
  geom_label_repel(
    min.segment.length = 0, force = 75, seed = 2024,
    size = 4, family = "sans_alt"
  ) +
  facet_wrap(~Speaker, ncol = 1) +  # <2>
  scale_color_manual(values = carto_pal(12, "Bold")) +
  scale_x_reverse(breaks = c(750, 1250, 1750, 2250, 2750)) +
  scale_y_reverse(breaks = c(250, 500, 750, 1000)) +
  theme_classic() +
  lingthusiasm_theme +
  theme(plot.subtitle = element_markdown(size = 15, family = "sans")) +
  labs(title = "Means By Word: Lingthusiasm Episodes", subtitle = vowel_key) +
  guides(color = guide_none())  # <12>

words_ep_1
```

1.  Only include `Lingthusiasm Episode` word list.
2.  The panels are stacked vertically, because the word labels take up more space. `fig-asp: 1.25` in this code chunk's header makes it render tall enough.

One thing that makes this plot a bit hard to interpret is that it's not immediately clear which vowel in the word is the one being plotted. So, let's make the vowel bold relative to the rest of the word.

So far we've been using `ggtext` to format text, but that doesn't work with `ggrepel`. The workaround, like with the IPA vowels, is to just enter the unicode characters directly.

These are the codes for the [Mathematical Sans Serif](https://www.compart.com/en/unicode/search?q=Mathematical+Sans-Serif+#characters) capital letters, in regular and bold faces. They're copy-pasted in here manually even though the pattern is predictable, because procedurally generating strings with the `\u` prefix is a pain.

```{r}
#| label: alphabet-unicode

alphabet_reg <- c(
  "\U1D5A0", "\U1D5A1", "\U1D5A2", "\U1D5A3", "\U1D5A4", "\U1D5A5",
  "\U1D5A6", "\U1D5A7", "\U1D5A8", "\U1D5A9", "\U1D5AA", "\U1D5AB",
  "\U1D5AC", "\U1D5AD", "\U1D5AE", "\U1D5AF", "\U1D5B0", "\U1D5B1",
  "\U1D5B2", "\U1D5B3", "\U1D5B4", "\U1D5B5", "\U1D5B6", "\U1D5B7",
  "\U1D5B8", "\U1D5B9"
)

alphabet_bold <- c(
  "\U1D5D4", "\U1D5D5", "\U1D5D6", "\U1D5D7", "\U1D5D8", "\U1D5D9",
  "\U1D5DA", "\U1D5DB", "\U1D5DC", "\U1D5DD", "\U1D5DE", "\U1D5DF",
  "\U1D5E0", "\U1D5E1", "\U1D5E2", "\U1D5E3", "\U1D5E4", "\U1D5E5",
  "\U1D5E6", "\U1D5E7", "\U1D5E8", "\U1D5E9", "\U1D5EA", "\U1D5EB",
  "\U1D5EC", "\U1D5ED"
)

names(alphabet_reg) <- letters[1:26]  # <1>
names(alphabet_bold) <- letters[1:26]  # <1>
```

1.  Name vectors with regular letters, to access similar to a python dictionary.

First, convert the whole word to the regular letters:

```{r}
#| label: function-to-unicode-caps

to_unicode_caps <- function(word, alphabet_reg) {  # <1>
  letters <- str_split(word, pattern = "")  # <2>
  converted <- ""  # <3>
  for (l in letters) {  # <4>
    new_word <- str_c(converted, alphabet_reg[l])  # <4>
  }  # <4>
  return(str_flatten(new_word))  # <5>
}
```

1.  Function takes `word` as a string and `alphabet_reg` as a named list.
2.  Split the word into individual letters.
3.  Start string for the converted word.
4.  For each letter, use the fact that `alphabet_reg` is named with the regular letters to get the unicode string for the current letter. Concatenate the letter pulled from `alphabet_reg` to the `converted` string.
5.  Combine list of letters back into one string.

```{r}
#| label: words-to-unicode

words_unicode <- map(formants$Word, to_unicode_caps, alphabet_reg)  # <1>

formants %<>% mutate(.after = Word, Word_Label = words_unicode) %>%  # <2>
  unnest(Word_Label)  # <3>
```

1.  For each item in the `Word` column of the `formants` dataframe, call the function `to_unicode_caps()` (defined in previous code chunk) on it. Pass `alphabet_reg` as the second argument to `to_unicode_caps()`.
2.  Insert the `words_unicode` into the `formants` dataframe as a column called `Word_Label`, after the `Word` column.
3.  Convert the items in `Word_Label` from lists containing 1 string to just strings.

Which renders as:

> `r unique(formants$Word_Label)`

Then convert the corresponding vowels to bold face.

```{r}
#| label: bold-vowels

formants %<>% mutate(  # <1>
  Word_Label = ifelse(  # <2>
    Word %in% c(  # <3>
      "ball", "bang", "bath", "beat", "father", "famous", "goat", "hand",  # <3>
      "laugh", "near", "palm", "says", "square", "start", "trap"  # <3>
    ),  # <3>
    str_replace(Word_Label, alphabet_reg["a"], alphabet_bold["a"]),  # <4>
    Word_Label  # <5>
  ),
  Word_Label = ifelse(  # <6>
    Word %in% c(  # <6>
      "beat", "bet", "blue", "dress", "fleece", "guest", "near", "people"  # <6>
    ),  # <6>
    str_replace(Word_Label, alphabet_reg["e"], alphabet_bold["e"]),  # <6>
    Word_Label  # <6>
  ),  # <6>
  Word_Label = ifelse(  # <7>
    Word %in% c("bit", "finish", "kit", "pin"),  # <7>
    str_replace(Word_Label, alphabet_reg["i"], alphabet_bold["i"]),  # <7>
    Word_Label  # <7>
  ),  # <7>
  Word_Label = ifelse(  # <8>
    Word %in% c(  # <8>
      "among", "another", "bought", "cloth", "core", "could", # <8>
      "force", "goat", "honorific", "lot", "people", "thought",  # <8>
      "through", "who", "wrong"  # <8>
    ),  # <8>
    str_replace(Word_Label, alphabet_reg["o"], alphabet_bold["o"]),  # <8>
    Word_Label  # <8>
  ),  # <8>
  Word_Label = ifelse(  # <9>
    Word %in% c(  # <9>
      "bought", "blue", "but", "could", "fun", "guest", "laugh",  # <9>
      "put", "strut", "square", "support", "thought", "through"  # <9>
    ),  # <9>
    str_replace(Word_Label, alphabet_reg["u"], alphabet_bold["u"]),  # <9>
    Word_Label  # <9>
  ),  # <9>
  Word_Label = ifelse(  # <10>
    Word == "believe",  # <10>
    str_replace(  # <10>
      Word_Label,  # <10>
      str_c(alphabet_reg["i"], alphabet_reg["e"]),  # <10>
      str_c(alphabet_bold["i"], alphabet_bold["e"])  # <10>
    ),  # <10>
    Word_Label  # <10>
  ),
  Word_Label = ifelse(  # <11>
    Word %in% c("goose", "foot"),  # <11>
    str_replace_all(
      Word_Label,
      str_c(alphabet_reg["o"], alphabet_reg["o"]),
      str_c(alphabet_bold["o"], alphabet_bold["o"])
    ),  # <11>
    Word_Label  # <11>
  ),
  Word_Label = ifelse(  # <12>
    Word == "fleece",  # <12>
    str_replace(Word_Label, alphabet_reg["e"], alphabet_bold["e"]),  # <12>
    Word_Label  # <12>
  )
)
formants$Word_Label %<>% as.factor()  # <13>
```

1.  Mutating the `Word_Label` column multiple times, because several words have multiple vowels to swap. Swapping one vowel at a time is shorter than swapping one category of word at time.
2.  First modification to `Word_Label` is all the words where "A" gets bolded.
3.  If the value in the `Word` column is one of these items
4.  Then pass the value of the `Word_Label` column to `str_replace()`. Replace the "a" from the regular-face set with the "a" from the bold-face set.
5.  If the value in the `Word` column is not any of those words, keep the value of `Word_Label` the same.
6.  Same logic for all the words where "E" gets bolded.
7.  Same logic for all the words where "I" gets bolded.
8.  Same logic for all the words where "O" gets bolded.
9.  Same logic for all the words where "U" gets bolded.
10. There are a couple of exceptions: "believe", because that's the word where the second instance of the vowel gets bolded, not the first one. Replace the consecutive "I" and "E" from the regular-face set with the "I" and "E" from the bold-face set.
11. "Goose" is the only word where both O's need to be bolded.
12. "Fleece" needs the first two, but not the third E bolded.
13. Convert `Word_Label` from character to factor.

Which renders as:

> `r levels(formants$Word_Label)`

Now we can see which vowels are being plotted more clearly (but with a reminder of how messy English orthography is):

```{r}
#| label: fig-by-word-ep-2
#| fig-cap: "Mean for each word in the Lingthusiasm Episode word list."
#| fig-asp: 1.25
#| warning: false

words_ep_2 <- formants %>%
  filter(List == "Lingthusiasm Episodes") %>%
  group_by(Speaker, Vowel, Word_Label) %>%  # <1>
  summarise(F1 = mean(F1), F2 = mean(F2)) %>%
  ggplot(aes(x = F2, y = F1, color = Vowel, label = Word_Label)) +  # <2>
  geom_point(size = 1.25) +
  geom_label_repel(min.segment.length = 0, force = 75, seed = 2024, size = 4) +
  facet_wrap(~Speaker, ncol = 1) +
  scale_color_manual(values = carto_pal(12, "Bold")) +
  scale_x_reverse(breaks = c(750, 1250, 1750, 2250, 2750)) +
  scale_y_reverse(breaks = c(250, 500, 750, 1000)) +
  theme_classic() +
  lingthusiasm_theme +
  theme(plot.subtitle = element_markdown(size = 15, family = "sans")) +
  labs(title = "Means By Word: Lingthusiasm Episodes", subtitle = vowel_key) +
  guides(color = guide_none())

words_ep_2
```

1.  Replace `Word` with `Word_Label`.
2.  Replace `Word` with `Word_Label` here too.

This was one of the points where I (from the northeast US) realized how I don't have a lot of experience with Australian accents, because I wasn't entirely sure how much of the messiness in Lauren's back vowel data was because her back vowels are in different locations, or because I picked words where she uses a different vowel than Gretchen and I do.


Save the plots: 

```{r}
#| label: export-plots

ggsave(
  means_1, path = "plots", filename = "1_means_original.png",
  width = 8, height = 5, unit = "in", device = png  # <1>
)
ggsave(
  means_2, path = "plots", filename = "2_means_flipped.png",
  width = 8, height = 5, unit = "in", device = png
)
ggsave(
  points, path = "plots", filename = "3_individual_points.png",
  width = 8, height = 5, unit = "in", device = png
)
ggsave(
  words_ls, path = "plots", filename = "4_words_lexical_set.png",
  width = 8, height = 5, unit = "in", device = png
)
ggsave(
  words_ep_2, path = "plots", filename = "4_words_episodes.png",
  width = 8, height = 8, unit = "in", device = png
)
```

1.  Need to specify `device = png` (not leave default or `device = "png"`) to get Josefin Sans font to render correctly.
